#pragma once
#include "SocialNetwork.h"
#include "algorithms/pagerank.h"
#include <iostream>
#include <fstream>
#include <string>
#include <unordered_set>
#include <set> // Required for std::set
#include "LogManager.h"

using namespace std;

class WebExporter {
public:
    // Exports the current graph state to a JavaScript file
    static void export_graph(const SocialNetwork& network, const string& filename = "graph_data.js") {
        ofstream out(filename);
        if (!out.is_open()) {
            cerr << "Error: Could not open " << filename << " for writing." << endl;
            return;
        }

        out << "// Auto-generated by C++ Social Network Backend\n";
        out << "const graphData = {\n";
        
        // --- Export Algorithm Metadata ---
        out << "  algorithm: {\n";
        out << "    name: \"" << LogManager::algorithmName << "\",\n";
        out << "    description: \"" << LogManager::algorithmDescription << "\",\n";
        out << "    targetUser: " << LogManager::targetUserID << "\n";
        out << "  },\n";
        
        // --- Calculate PageRank for all users ---
        unordered_map<int, double> pagerank_scores = calculate_pagerank(network);
        
        // --- 1. Export Nodes ---
        out << "  nodes: [\n";
        const auto& users = network.get_all_users();
        int counter = 0;
        int totalUsers = users.size();
        
        for (int userID : users) {
            // Get user tags to determine "group" or color
            const auto& tags = network.get_tags(userID);
            string group = "default";
            
            // Heuristic for coloring based on tags (Bonus Feature)
            if (tags.count("coding") || tags.count("python") || tags.count("C++")) group = "coding";
            else if (tags.count("music") || tags.count("art") || tags.count("painting")) group = "art";
            else if (tags.count("football") || tags.count("gym") || tags.count("basketball")) group = "sports";

            // Format: { id: 1, label: '1', group: 'coding', title: 'Tags: ...' },
            out << "    { id: " << userID 
                << ", label: '" << userID << "'"
                << ", group: '" << group << "'"
                << ", title: 'Tags: ";
                
            for (const string& t : tags) out << t << " ";
            out << "' }";
            
            if (counter < totalUsers - 1) out << ",";
            out << "\n";
            counter++;
        }
        out << "  ],\n";

        out << "  history: [\n";
        for (size_t i = 0; i < LogManager::events.size(); ++i) {
            const auto& ev = LogManager::events[i];
            // Write: { type: 'visit', id: 5, from: 2, val: 0.85 },
            out << "    { type: '" << ev.type << "', id: " << ev.nodeID 
                << ", from: " << ev.fromID << ", val: " << ev.value << " }";
            
            if (i < LogManager::events.size() - 1) out << ",";
            out << "\n";
        }
        out << "  ],\n"; // End of history array

        // --- 2. Export Edges ---
        out << "  edges: [\n";
        set<pair<int, int>> savedEdges; // To avoid duplicates (1-2 and 2-1)
        
        counter = 0;
        // We iterate efficiently using a similar logic to your save_data method
        // But we need to gather them all first to handle the trailing comma correctly (optional for JS but good practice)
        vector<pair<int, int>> allEdges;
        for (int userA : users) {
            for (int userB : network.get_friends(userA)) {
                if (userA < userB) { // Only save one direction to prevent double lines
                    allEdges.push_back({userA, userB});
                }
            }
        }

        for (size_t i = 0; i < allEdges.size(); ++i) {
            out << "    { from: " << allEdges[i].first << ", to: " << allEdges[i].second << " }";
            if (i < allEdges.size() - 1) out << ",";
            out << "\n";
        }
        out << "  ],\n";
        
        // --- 3. Export User Details (for Profile Card) ---
        out << "  user_details: {\n";
        counter = 0;
        for (int userID : users) {
            const auto& tags = network.get_tags(userID);
            const auto& friends = network.get_friends(userID);
            double pagerank = pagerank_scores.count(userID) ? pagerank_scores[userID] : 0.0;
            
            out << "    " << userID << ": {\n";
            out << "      id: " << userID << ",\n";
            out << "      name: \"User " << userID << "\",\n";
            out << "      tags: [";
            
            // Export tags as array
            int tagCounter = 0;
            for (const string& tag : tags) {
                out << "\"" << tag << "\"";
                if (++tagCounter < tags.size()) out << ", ";
            }
            out << "],\n";
            
            out << "      friends: [";
            // Export friend IDs
            int friendCounter = 0;
            for (int friendID : friends) {
                out << friendID;
                if (++friendCounter < friends.size()) out << ", ";
            }
            out << "],\n";
            
            out << "      friendCount: " << friends.size() << ",\n";
            out << "      pagerank: " << pagerank << "\n";
            out << "    }";
            
            if (++counter < totalUsers) out << ",";
            out << "\n";
        }
        out << "  }\n";
        out << "};\n";

        cout << "Success! Graph data exported to " << filename << endl;
        cout << "Open index.html in your browser to view the visualization." << endl;
        out.close();
    }
};